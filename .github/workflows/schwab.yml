---  # yamllint disable rule:line-length rule:truthy
name: Schwab Probe

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["LeoCross Ticket"]   # must match your leocross.yml name
    types: [completed]

concurrency:
  group: schwab-probe-${{ github.event.workflow_run.id || github.run_id }}
  cancel-in-progress: false

jobs:
  probe:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install --quiet schwab-py google-api-python-client google-auth google-auth-httplib2

      - name: Schwab top-insert + PLACE order (read leocross row 2) — SPXW ONLY
        env:
          SCHWAB_APP_KEY: ${{ secrets.SCHWAB_APP_KEY }}
          SCHWAB_APP_SECRET: ${{ secrets.SCHWAB_APP_SECRET }}
          SCHWAB_TOKEN_JSON: ${{ secrets.SCHWAB_TOKEN_JSON }}
          GSHEET_ID: ${{ secrets.GSHEET_ID }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          NET_PRICE: ${{ vars.NET_PRICE }}            # optional; default 0.05
          SCHWAB_PLACE_VAR: ${{ vars.SCHWAB_PLACE }}  # accept var OR secret
          SCHWAB_PLACE_SEC: ${{ secrets.SCHWAB_PLACE }}
        run: |
          python - <<'PY'
          import os, re, json, sys
          from datetime import datetime, timezone
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from schwab.auth import client_from_token_file

          # --- resolve mode (place only; no preview path) ---
          _mode = (os.environ.get("SCHWAB_PLACE_VAR")
                   or os.environ.get("SCHWAB_PLACE_SEC") or "").lower()
          place_flag = (_mode == "place")
          print("MODE", "PLACE" if place_flag else "SKIP (no preview)")

          # --- Schwab client ---
          open("schwab_token.json", "w").write(os.environ["SCHWAB_TOKEN_JSON"])
          c = client_from_token_file(
              api_key=os.environ["SCHWAB_APP_KEY"],
              app_secret=os.environ["SCHWAB_APP_SECRET"],
              token_path="schwab_token.json"
          )

          # account
          r = c.get_account_numbers(); r.raise_for_status()
          acct = r.json()[0]
          acct_hash = acct["hashValue"]
          acct_last4 = acct["accountNumber"][-4:]

          # --- Sheets client ---
          sa = json.loads(os.environ["GOOGLE_SERVICE_ACCOUNT_JSON"])
          creds = service_account.Credentials.from_service_account_info(
              sa,
              scopes=["https://www.googleapis.com/auth/spreadsheets"],
          )
          s = build("sheets", "v4", credentials=creds)
          sid = os.environ["GSHEET_ID"]
          tab_schwab = "schwab"
          tab_leo = "leocross"

          # header (schwab)
          header = [
              "ts", "source", "account_hash", "account_last4", "symbol",
              "last_price", "signal_date", "order_mode", "side", "qty_exec",
              "order_type", "limit_price", "occ_buy_put", "occ_sell_put",
              "occ_sell_call", "occ_buy_call", "order_id", "status"
          ]
          got = s.spreadsheets().values().get(
              spreadsheetId=sid, range=f"{tab_schwab}!1:1"
          ).execute().get("values", [])
          if not got or got[0] != header:
              s.spreadsheets().values().update(
                  spreadsheetId=sid,
                  range=f"{tab_schwab}!1:1",
                  valueInputOption="USER_ENTERED",
                  body={"values": [header]},
              ).execute()

          # get sheetId for top-insert
          meta = s.spreadsheets().get(spreadsheetId=sid).execute()
          sheet_id = next(
              sh["properties"]["sheetId"]
              for sh in meta["sheets"]
              if sh["properties"]["title"] == tab_schwab
          )

          def top_insert():
              s.spreadsheets().batchUpdate(
                  spreadsheetId=sid,
                  body={"requests": [{
                      "insertDimension": {
                          "range": {
                              "sheetId": sheet_id,
                              "dimension": "ROWS",
                              "startIndex": 1,
                              "endIndex": 2,
                          },
                          "inheritFromBefore": False,
                      }
                  }]}
              ).execute()

          # PROBE row at A2 (label symbol "SPXW" and leave price empty; heartbeat)
          top_insert()
          s.spreadsheets().values().update(
              spreadsheetId=sid,
              range=f"{tab_schwab}!A2",
              valueInputOption="USER_ENTERED",
              body={"values": [[
                  datetime.now(timezone.utc).isoformat(),
                  "SCHWAB_PROBE",
                  acct_hash, acct_last4, "SPXW", "",
                  "", "", "", "", "", "", "", "", "", "", "", "",
              ]]}
          ).execute()
          print("schwab: inserted probe at A2")

          # --- Read leocross row 2 (latest) ---
          rows = s.spreadsheets().values().get(
              spreadsheetId=sid, range=f"{tab_leo}!A1:Z2"
          ).execute().get("values", [])
          if len(rows) < 2:
              print("No leocross row 2; nothing to place."); sys.exit(0)
          leo_header, leo_row2 = rows[0], rows[1]
          idx = {n: i for i, n in enumerate(leo_header)}

          def g(col):
              j = idx.get(col, -1)
              return leo_row2[j] if 0 <= j < len(leo_row2) else ""

          # Legs must be present and SPXW-only
          raw_legs = [
              g("occ_buy_put"), g("occ_sell_put"),
              g("occ_sell_call"), g("occ_buy_call")
          ]
          if not all(raw_legs):
              print("Row 2 missing one or more leg symbols; nothing to place.")
              sys.exit(0)

          def is_spxw(s): return (s or "").upper().startswith("SPXW")

          if not all(map(is_spxw, raw_legs)):
              print("Non-SPXW leg detected; enforcing SPXW-only → skip.")
              sys.exit(0)

          # Convert to Schwab’s 21-char OCC (root padded to 6)
          # Accepts:
          #   .SPXW250821P6365
          #   SPXW_250821P06365000
          #   'SPXW  250821P06365000' (already padded)
          def to_schwab_opt(sym):
              raw = (sym or "").strip().upper()
              if raw.startswith("."):
                  raw = raw[1:]
              raw = raw.replace("_", "")
              m = re.match(r'^([A-Z.$^]{1,6})(\d{6})([CP])(\d{8})$', raw)
              if m:
                  root, ymd, cp, strike8 = m.groups()
                  if root != "SPXW":
                      raise ValueError(f"Non-SPXW root: {root}")
                  return f"{root:<6}{ymd}{cp}{strike8}"
              m = re.match(r'^([A-Z.$^]{1,6})(\d{6})([CP])(\d{1,5})(?:\.(\d{1,3}))?$', raw)
              if m:
                  root, ymd, cp, i, frac = m.groups()
                  if root != "SPXW":
                      raise ValueError(f"Non-SPXW root: {root}")
                  mills = int(i)*1000 + (int(frac.ljust(3, '0')) if frac else 0)
                  strike8 = f"{mills:08d}"
                  return f"{root:<6}{ymd}{cp}{strike8}"
              m = re.match(r'^(.{6})(\d{6})([CP])(\d{8})$', sym or "")
              if m:
                  root6, ymd, cp, strike8 = m.groups()
                  if not root6.strip().upper().startswith("SPXW"):
                      raise ValueError(f"Non-SPXW root: {root6}")
                  return f"{root6}{ymd}{cp}{strike8}"
              raise ValueError(f"Cannot parse option symbol: {sym}")

          leg_syms = [to_schwab_opt(x) for x in raw_legs]
          print("FORMATTED_LEGS", leg_syms)

          # Idempotency: if these raw legs are already logged as placed, skip
          all_rows = s.spreadsheets().values().get(
              spreadsheetId=sid, range=f"{tab_schwab}!A1:Z100000"
          ).execute().get("values", [])
          if all_rows:
              h, data = all_rows[0], all_rows[1:]
              hidx = {n: i for i, n in enumerate(h)}

              def cell(r, c):
                  j = hidx.get(c, -1)
                  return (r[j] if 0 <= j < len(r) else "").upper()

              sig = [x.upper() for x in raw_legs]
              for r in data:
                  if cell(r, "source") in ("SCHWAB_PLACED", "SCHWAB_ORDER"):
                      if [
                          cell(r, "occ_buy_put"),
                          cell(r, "occ_sell_put"),
                          cell(r, "occ_sell_call"),
                          cell(r, "occ_buy_call"),
                      ] == sig:
                          print("Duplicate legs already logged; skip placing.")
                          sys.exit(0)

          # Build order from row 2
          qty_exec = int((g("qty_exec") or "1"))
          side = (g("side") or "").upper()
          credit_or_debit = (g("credit_or_debit") or "").lower()
          is_credit = (credit_or_debit == "credit") or side.startswith("SHORT")
          order_type = "NET_CREDIT" if is_credit else "NET_DEBIT"
          limit = str(os.environ.get("NET_PRICE") or "0.05")

          order = {
              "orderType": order_type,
              "session": "NORMAL",
              "price": limit,
              "duration": "DAY",
              "orderStrategyType": "SINGLE",
              "complexOrderStrategyType": "IRON_CONDOR",
              "orderLegCollection": [
                  {"instruction": "BUY_TO_OPEN", "quantity": qty_exec,
                   "instrument": {"symbol": leg_syms[0], "assetType": "OPTION"}},
                  {"instruction": "SELL_TO_OPEN", "quantity": qty_exec,
                   "instrument": {"symbol": leg_syms[1], "assetType": "OPTION"}},
                  {"instruction": "SELL_TO_OPEN", "quantity": qty_exec,
                   "instrument": {"symbol": leg_syms[2], "assetType": "OPTION"}},
                  {"instruction": "BUY_TO_OPEN", "quantity": qty_exec,
                   "instrument": {"symbol": leg_syms[3], "assetType": "OPTION"}},
              ],
          }

          # Place ONLY if toggle says so
          if not place_flag:
              print("Toggle not 'place' → skipping order placement.")
              sys.exit(0)

          place_http = None
          order_id = ""
          try:
              ok = c.place_order(acct_hash, order)
              place_http = ok.status_code
              print("PLACE_HTTP", place_http)
              try:
                  j = ok.json()
                  order_id = str(j.get("orderId") or j.get("order_id") or "")
              except Exception:
                  order_id = ""
          except Exception as e:
              print("ORDER_ERROR", e)

          # Log the placed order row at top for dedupe
          top_insert()
          s.spreadsheets().values().update(
              spreadsheetId=sid,
              range=f"{tab_schwab}!A2",
              valueInputOption="USER_ENTERED",
              body={"values": [[
                  datetime.now(timezone.utc).isoformat(),
                  "SCHWAB_PLACED",
                  acct_hash, acct_last4, "SPXW", "",
                  g("signal_date"), "PLACE", side, qty_exec,
                  order_type, limit,
                  raw_legs[0], raw_legs[1], raw_legs[2], raw_legs[3],
                  order_id, (place_http if place_http is not None else ""),
              ]]}
          ).execute()

          # Summary
          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
              f.write(
                  "### Schwab order (SPXW only, PLACE only)\n\n```\n"
                  + json.dumps(order, indent=2)
                  + "\n```\n"
              )
              f.write(f"- account_last4: {acct_last4}\n")
              f.write(f"- read leocross row: 2\n")
              f.write(f"- mode: PLACE\n")
              f.write(f"- order_id: {order_id}\n")
              f.write(f"- http_status: {place_http}\n")
              f.write(f"- legs formatted: {leg_syms}\n")
          PY
