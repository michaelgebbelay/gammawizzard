name: schwab_spx_only_probe

on:
  workflow_dispatch:
    inputs:
      for_date:
        description: "Trading date (YYYY-MM-DD, ET). Example: 2025-11-07"
        required: true

jobs:
  probe:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas pytz schwab-py

      - name: Run SPX-only probe (inline Python)
        env:
          SCHWAB_APP_KEY:    ${{ secrets.SCHWAB_APP_KEY }}
          SCHWAB_APP_SECRET: ${{ secrets.SCHWAB_APP_SECRET }}
          SCHWAB_TOKEN_JSON: ${{ secrets.SCHWAB_TOKEN_JSON }}
          FOR_DATE:          ${{ inputs.for_date }}
        run: |
          python -u - <<'PY'
          from __future__ import annotations
          import os, sys, json, time, argparse, datetime as dt
          import pandas as pd, pytz
          from schwab.auth import client_from_token_file

          BASE = "https://api.schwabapi.com/marketdata/v1"
          ET = pytz.timezone("America/New_York")

          def et_epoch_ms(y,m,d,hh,mm): return int(ET.localize(dt.datetime(y,m,d,hh,mm)).timestamp()*1000)

          def client():
              app_key    = os.environ["SCHWAB_APP_KEY"]
              app_secret = os.environ["SCHWAB_APP_SECRET"]
              token_json = os.environ["SCHWAB_TOKEN_JSON"]
              with open("schwab_token.json","w") as f: f.write(token_json)
              return client_from_token_file(api_key=app_key, app_secret=app_secret, token_path="schwab_token.json")

          def get_json(sess, url, params=None, tag=""):
              r = sess.get(url, params=params, timeout=25)
              if r.status_code != 200:
                  print(f"[{tag}] HTTP_{r.status_code} → {r.text[:250]}", flush=True)
                  return False, {}
              try:    return True, r.json()
              except: return True, {}

          def auth_ok(c):
              r = c.get_account_numbers(); r.raise_for_status()
              print(f"[OK] auth → account hash: {r.json()[0]['hashValue']}", flush=True); return True

          def spx_last(sess):
              for sym in ["$SPX.X","SPX"]:
                  ok,d = get_json(sess, f"{BASE}/quotes", {"symbols": sym}, tag=f"quotes {sym}")
                  if ok and isinstance(d,dict) and d:
                      payload = list(d.values())[0]
                      q = payload.get("quote") or payload
                      last = q.get("lastPrice") or q.get("regularMarketLastPrice") or q.get("last")
                      if last is not None:
                          print(f"[OK] underlying → {sym} last={last}", flush=True); return sym,float(last)
              print("[FAIL] underlying → no $SPX.X or SPX last", flush=True); return None,None

          def request_pricehistory(sess, sym, start_ms, end_ms, freq):
              routes = [(f"{BASE}/pricehistory", {"symbol":sym}), (f"{BASE}/pricehistory/{sym}", {})]
              add = {"startDate":start_ms,"endDate":end_ms,"frequencyType":"minute","frequency":freq,"needExtendedHoursData":"false"}
              for url,base in routes:
                  ok,d = get_json(sess,url,{**base,**add},tag=f"pricehistory {sym} f{freq}")
                  candles = (d.get("candles") or d.get("data",{}).get("candles") or []) if ok else []
                  if ok and candles:
                      df = pd.DataFrame(candles)
                      tcol = "datetime" if "datetime" in df.columns else ("time" if "time" in df.columns else None)
                      if not tcol: continue
                      df["ts"] = pd.to_datetime(df[tcol], unit="ms", utc=True)
                      return df.set_index("ts").sort_index()
              return None

          def spx_intraday(sess, d):
              y,m,dd = d.year,d.month,d.day
              start_ms, end_ms = et_epoch_ms(y,m,dd,9,30), et_epoch_ms(y,m,dd,16,0)
              for freq in [1,5]:
                  for sym in ["$SPX.X","SPX.X","SPX"]:
                      df = request_pricehistory(sess,sym,start_ms,end_ms,freq)
                      if df is not None and not df.empty:
                          print(f"[OK] pricehistory → {sym} {d}: {len(df)} x {freq}m bars (first {df.index[0]}, last {df.index[-1]})", flush=True)
                          return True
              print(f"[FAIL] pricehistory → SPX-only: no bars for {d} on [$SPX.X, SPX.X, SPX] (1m/5m)", flush=True); return False

          def occ_spxw_symbol(d, right, strike_int):
              root6 = f"{'SPXW':<6}"  # 'SPXW  '
              yymmdd = d.strftime("%y%m%d")
              cp = right.upper()[0]
              return f"{root6}{yymmdd}{cp}{int(round(strike_int*1000)):08d}"

          def round5(x): return int(round(x/5.0)*5)

          def spxw_quotes(sess, d, ref_last):
              if ref_last is None:
                  print("[WARN] spxw_quotes → no SPX last; using 5000 as ATM probe", flush=True)
                  ref_last = 5000.0
              atm = round5(ref_last)
              strikes = [atm + 5*k for k in range(-5,6)]
              occs=[]
              for k in strikes:
                  occs += [occ_spxw_symbol(d,"C",k), occ_spxw_symbol(d,"P",k)]
              ok,data = get_json(sess,f"{BASE}/quotes",{"symbols":",".join(occs)},tag=f"quotes OCC {d}")
              if not ok or not isinstance(data,dict) or not data:
                  print(f"[FAIL] spxw_quotes → empty payload for {d}", flush=True); return False
              count=0; printed=0
              for sym,p in data.items():
                  q = p.get("quote") or p
                  if str(q.get("assetMainType","")).upper() != "OPTION": continue
                  bid = q.get("bidPrice") or q.get("bid") or q.get("bidPriceInDouble")
                  ask = q.get("askPrice") or q.get("ask") or q.get("askPriceInDouble")
                  delta = q.get("delta")
                  count += 1
                  if printed < 10:
                      print(f"  [OPT] {sym}: bid={bid} ask={ask} delta={delta}", flush=True)
                      printed += 1
              if count==0:
                  print(f"[FAIL] spxw_quotes → parsed 0 options for {d}", flush=True); return False
              print(f"[OK] spxw_quotes → {count} SPXW entries for {d}", flush=True); return True

          # ---- main ----
          for_date = os.environ.get("FOR_DATE")
          if not for_date: 
              print("Missing input FOR_DATE", flush=True); sys.exit(2)
          y,m,d = map(int, for_date.split("-"))
          target = dt.date(y,m,d)

          c = client()
          ok_auth = auth_ok(c)
          sym,last = spx_last(c.session)
          ok_hist  = spx_intraday(c.session, target)
          ok_opt   = spxw_quotes(c.session, target, last)

          print(f"\nRESULTS: DATE={target} | AUTH={'OK' if ok_auth else 'FAIL'} | "
                f"SPX_QUOTE={'OK' if last is not None else 'FAIL'} | "
                f"SPX_INTRADAY={'OK' if ok_hist else 'FAIL'} | "
                f"SPXW_QUOTES={'OK' if ok_opt else 'FAIL'}", flush=True)
          PY
